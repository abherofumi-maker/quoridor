<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quoridor CPU</title>

<style>
body{
  margin:0;
  background:#181b20;
  color:#eee;
  font-family:system-ui, sans-serif;
  display:flex;
  flex-direction:column;
  align-items:center;
}

h1{
  font-weight:300;
  letter-spacing:4px;
  margin:15px 0;
}

#game{
  display:flex;
  align-items:center;
}

.side-space{
  width:min(90vw,520px)/9;
}

#board-wrapper{
  position:relative;
}

#board{
  display:grid;
  grid-template-columns:repeat(9,1fr);
  grid-template-rows:repeat(9,1fr);
  width:min(90vw,520px);
  aspect-ratio:1;
  gap:4px;
}

.cell{
  background:#2a2f38;
  border-radius:6px;
  position:relative;
  cursor:pointer;
}

.pawn{
  width:65%;
  height:65%;
  border-radius:50%;
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  transition:.25s ease;
}

.active{
  box-shadow:0 0 0 4px rgba(255,255,255,0.8);
}

.p1{ background:#c9a227; } /* CPU */
.p2{ background:#3f88c5; } /* Human */

.wall{
  position:absolute;
  background:#ffffff;
  border-radius:4px;
  opacity:0;
  animation:fadeIn .2s forwards;
}

@keyframes fadeIn{ to{opacity:1;} }

#status{ margin-top:10px; }
</style>
</head>
<body>

<h1>QUORIDOR</h1>

<div id="game">
  <div id="leftSpace"></div>
  <div id="board-wrapper"><div id="board"></div></div>
  <div id="rightSpace"></div>
</div>

<div id="status"></div>

<script>
const size=9;
let board=document.getElementById("board");
let wrapper=document.getElementById("board-wrapper");

let current=1; // 1=CPU(orange)
let wallsLeft={1:10,2:10};
let pawns={1:{x:4,y:0},2:{x:4,y:8}};
let walls=[];

/* ===== 余白を1マス幅に調整 ===== */
function adjustSideSpace(){
  let cellSize=board.clientWidth/9;
  document.getElementById("leftSpace").style.width=cellSize+"px";
  document.getElementById("rightSpace").style.width=cellSize+"px";
}
window.addEventListener("resize",()=>{drawBoard();});

/* ===== 描画 ===== */
function drawBoard(){
  board.innerHTML="";
  wrapper.querySelectorAll(".wall").forEach(w=>w.remove());

  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      let cell=document.createElement("div");
      cell.className="cell";
      cell.onclick=()=>humanMove(x,y);
      board.appendChild(cell);
    }
  }

  drawPawns();
  drawWalls();
  adjustSideSpace();
  updateStatus();
}

function drawPawns(){
  for(let p=1;p<=2;p++){
    let pos=pawns[p];
    let cell=board.children[pos.y*9+pos.x];
    let pawn=document.createElement("div");
    pawn.className="pawn p"+p;
    if(p===current) pawn.classList.add("active");
    cell.appendChild(pawn);
  }
}

function drawWalls(){
  walls.forEach(w=>{
    let div=document.createElement("div");
    div.className="wall";
    let cellSize=board.clientWidth/9;

    if(w.dir==="h"){
      div.style.width=(cellSize*2+4)+"px";
      div.style.height="8px";
      div.style.left=(w.x*cellSize)+"px";
      div.style.top=(w.y*cellSize-4)+"px";
    }else{
      div.style.height=(cellSize*2+4)+"px";
      div.style.width="8px";
      div.style.left=(w.x*cellSize-4)+"px";
      div.style.top=(w.y*cellSize)+"px";
    }
    wrapper.appendChild(div);
  });
}

/* ===== 移動 ===== */

function humanMove(x,y){
  if(current!==2) return;
  if(validMove(2,x,y)){
    pawns[2]={x,y};
    endTurn();
  }
}

function cpuTurn(){
  if(current!==1) return;

  setTimeout(()=>{
    // 80% 移動 / 20% 壁
    if(Math.random()<0.2 && wallsLeft[1]>0){
      tryPlaceBlockingWall();
    }else{
      let move=shortestStep(1);
      if(move) pawns[1]=move;
    }
    endTurn();
  },400);
}

function endTurn(){
  if(checkWin(current)){
    setTimeout(()=>alert((current===1?"CPU":"YOU")+" 勝利！"),200);
    setTimeout(()=>location.reload(),600);
    return;
  }

  current=current===1?2:1;
  drawBoard();
  if(current===1) cpuTurn();
}

/* ===== ロジック ===== */

function validMove(player,x,y){
  let dx=Math.abs(pawns[player].x-x);
  let dy=Math.abs(pawns[player].y-y);
  if(dx+dy!==1) return false;
  if(isBlocked(pawns[player].x,pawns[player].y,x,y)) return false;
  return true;
}

function checkWin(player){
  return (player===1 && pawns[1].y===8) ||
         (player===2 && pawns[2].y===0);
}

function isBlocked(x1,y1,x2,y2){
  return walls.some(w=>{
    if(w.dir==="h"){
      if(y1===w.y && y2===w.y+1 && x1>=w.x && x1<w.x+2)return true;
      if(y2===w.y && y1===w.y+1 && x1>=w.x && x1<w.x+2)return true;
    }
    if(w.dir==="v"){
      if(x1===w.x && x2===w.x+1 && y1>=w.y && y1<w.y+2)return true;
      if(x2===w.x && x1===w.x+1 && y1>=w.y && y1<w.y+2)return true;
    }
    return false;
  });
}

/* ===== 最短1手（BFS） ===== */

function shortestStep(player){
  let goalRow = player===1?8:0;
  let visited=new Set();
  let queue=[[pawns[player],[]]];

  while(queue.length){
    let [pos,path]=queue.shift();
    let key=pos.x+","+pos.y;
    if(visited.has(key)) continue;
    visited.add(key);

    if(pos.y===goalRow){
      return path[0];
    }

    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      let nx=pos.x+dx, ny=pos.y+dy;
      if(nx>=0&&nx<9&&ny>=0&&ny<9){
        if(!isBlocked(pos.x,pos.y,nx,ny)){
          queue.push([{x:nx,y:ny}, [...path,{x:nx,y:ny}]]);
        }
      }
    });
  }
  return null;
}

/* ===== 簡易妨害壁 ===== */

function tryPlaceBlockingWall(){
  let target=pawns[2];
  let dir="h";
  let x=target.x;
  let y=target.y-1;

  if(canPlaceWall(x,y,dir)){
    walls.push({x,y,dir});
    wallsLeft[1]--;
  }else{
    let move=shortestStep(1);
    if(move) pawns[1]=move;
  }
}

function canPlaceWall(x,y,dir){
  if(dir==="h"&&(y<=0||x>=8))return false;
  walls.push({x,y,dir});
  let ok=pathExists(1)&&pathExists(2);
  walls.pop();
  return ok;
}

function pathExists(player){
  let goalRow = player===1?8:0;
  let visited=new Set();
  let queue=[pawns[player]];
  while(queue.length){
    let pos=queue.shift();
    let key=pos.x+","+pos.y;
    if(visited.has(key)) continue;
    visited.add(key);
    if(pos.y===goalRow) return true;

    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      let nx=pos.x+dx, ny=pos.y+dy;
      if(nx>=0&&nx<9&&ny>=0&&ny<9){
        if(!isBlocked(pos.x,pos.y,nx,ny)){
          queue.push({x:nx,y:ny});
        }
      }
    });
  }
  return false;
}

function updateStatus(){
  document.getElementById("status").innerText=
  current===1?"CPUのターン":"あなたのターン";
}

drawBoard();
cpuTurn(); // CPU先手
</script>
</body>
</html>
